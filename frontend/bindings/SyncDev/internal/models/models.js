// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as time$0 from "../../../time/models.js";

/**
 * AggregateProgress represents overall sync progress across all files
 */
export class AggregateProgress {
    /**
     * Creates a new AggregateProgress instance.
     * @param {Partial<AggregateProgress>} [$$source = {}] - The source object to create the AggregateProgress.
     */
    constructor($$source = {}) {
        if (!("status" in $$source)) {
            /**
             * "idle", "syncing", "complete"
             * @member
             * @type {string}
             */
            this["status"] = "";
        }
        if (!("totalFiles" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["totalFiles"] = 0;
        }
        if (!("completedFiles" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["completedFiles"] = 0;
        }
        if (!("totalBytes" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["totalBytes"] = 0;
        }
        if (!("transferredBytes" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["transferredBytes"] = 0;
        }
        if (!("percentage" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["percentage"] = 0;
        }
        if (!("bytesPerSecond" in $$source)) {
            /**
             * smoothed speed
             * @member
             * @type {number}
             */
            this["bytesPerSecond"] = 0;
        }
        if (!("eta" in $$source)) {
            /**
             * seconds remaining, -1 if unknown
             * @member
             * @type {number}
             */
            this["eta"] = 0;
        }
        if (!("activeFiles" in $$source)) {
            /**
             * max 10 files
             * @member
             * @type {FileProgress[]}
             */
            this["activeFiles"] = [];
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new AggregateProgress instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {AggregateProgress}
     */
    static createFrom($$source = {}) {
        const $$createField8_0 = $$createType1;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("activeFiles" in $$parsedSource) {
            $$parsedSource["activeFiles"] = $$createField8_0($$parsedSource["activeFiles"]);
        }
        return new AggregateProgress(/** @type {Partial<AggregateProgress>} */($$parsedSource));
    }
}

/**
 * FileInfo represents metadata about a file in the sync index
 */
export class FileInfo {
    /**
     * Creates a new FileInfo instance.
     * @param {Partial<FileInfo>} [$$source = {}] - The source object to create the FileInfo.
     */
    constructor($$source = {}) {
        if (!("path" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["path"] = "";
        }
        if (!("size" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["size"] = 0;
        }
        if (!("modTime" in $$source)) {
            /**
             * @member
             * @type {time$0.Time}
             */
            this["modTime"] = null;
        }
        if (!("hash" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["hash"] = "";
        }
        if (!("isDir" in $$source)) {
            /**
             * @member
             * @type {boolean}
             */
            this["isDir"] = false;
        }
        if (!("permission" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["permission"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new FileInfo instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {FileInfo}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new FileInfo(/** @type {Partial<FileInfo>} */($$parsedSource));
    }
}

/**
 * FileProgress represents progress for a single file
 */
export class FileProgress {
    /**
     * Creates a new FileProgress instance.
     * @param {Partial<FileProgress>} [$$source = {}] - The source object to create the FileProgress.
     */
    constructor($$source = {}) {
        if (!("path" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["path"] = "";
        }
        if (!("size" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["size"] = 0;
        }
        if (!("transferred" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["transferred"] = 0;
        }
        if (!("percentage" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["percentage"] = 0;
        }
        if (!("status" in $$source)) {
            /**
             * "active", "pending", "complete"
             * @member
             * @type {string}
             */
            this["status"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new FileProgress instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {FileProgress}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new FileProgress(/** @type {Partial<FileProgress>} */($$parsedSource));
    }
}

/**
 * FolderPair represents a pair of folders to sync between local and remote
 */
export class FolderPair {
    /**
     * Creates a new FolderPair instance.
     * @param {Partial<FolderPair>} [$$source = {}] - The source object to create the FolderPair.
     */
    constructor($$source = {}) {
        if (!("id" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["id"] = "";
        }
        if (!("peerId" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["peerId"] = "";
        }
        if (!("localPath" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["localPath"] = "";
        }
        if (!("remotePath" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["remotePath"] = "";
        }
        if (!("enabled" in $$source)) {
            /**
             * @member
             * @type {boolean}
             */
            this["enabled"] = false;
        }
        if (!("exclusions" in $$source)) {
            /**
             * @member
             * @type {string[]}
             */
            this["exclusions"] = [];
        }
        if (/** @type {any} */(false)) {
            /**
             * @member
             * @type {time$0.Time | undefined}
             */
            this["lastSyncTime"] = undefined;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new FolderPair instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {FolderPair}
     */
    static createFrom($$source = {}) {
        const $$createField5_0 = $$createType2;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("exclusions" in $$parsedSource) {
            $$parsedSource["exclusions"] = $$createField5_0($$parsedSource["exclusions"]);
        }
        return new FolderPair(/** @type {Partial<FolderPair>} */($$parsedSource));
    }
}

/**
 * Peer represents a remote device that can sync with this instance
 */
export class Peer {
    /**
     * Creates a new Peer instance.
     * @param {Partial<Peer>} [$$source = {}] - The source object to create the Peer.
     */
    constructor($$source = {}) {
        if (!("id" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["id"] = "";
        }
        if (!("name" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["name"] = "";
        }
        if (!("host" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["host"] = "";
        }
        if (!("port" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["port"] = 0;
        }
        if (!("version" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["version"] = "";
        }
        if (!("status" in $$source)) {
            /**
             * @member
             * @type {PeerStatus}
             */
            this["status"] = PeerStatus.$zero;
        }
        if (/** @type {any} */(false)) {
            /**
             * @member
             * @type {string | undefined}
             */
            this["sharedSecret"] = undefined;
        }
        if (!("paired" in $$source)) {
            /**
             * @member
             * @type {boolean}
             */
            this["paired"] = false;
        }
        if (!("lastSeen" in $$source)) {
            /**
             * @member
             * @type {time$0.Time}
             */
            this["lastSeen"] = null;
        }
        if (/** @type {any} */(false)) {
            /**
             * @member
             * @type {time$0.Time | undefined}
             */
            this["lastSyncTime"] = undefined;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Peer instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {Peer}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Peer(/** @type {Partial<Peer>} */($$parsedSource));
    }
}

/**
 * PeerStatus represents the current status of a peer
 * @readonly
 * @enum {string}
 */
export const PeerStatus = {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero: "",

    PeerStatusOnline: "online",
    PeerStatusOffline: "offline",
    PeerStatusSyncing: "syncing",
    PeerStatusPairing: "pairing",
};

/**
 * TransferProgress represents the progress of a file transfer
 */
export class TransferProgress {
    /**
     * Creates a new TransferProgress instance.
     * @param {Partial<TransferProgress>} [$$source = {}] - The source object to create the TransferProgress.
     */
    constructor($$source = {}) {
        if (!("fileName" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["fileName"] = "";
        }
        if (!("totalBytes" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["totalBytes"] = 0;
        }
        if (!("transferBytes" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["transferBytes"] = 0;
        }
        if (!("percentage" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["percentage"] = 0;
        }
        if (!("bytesPerSecond" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["bytesPerSecond"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new TransferProgress instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {TransferProgress}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new TransferProgress(/** @type {Partial<TransferProgress>} */($$parsedSource));
    }
}

// Private type creation functions
const $$createType0 = FileProgress.createFrom;
const $$createType1 = $Create.Array($$createType0);
const $$createType2 = $Create.Array($Create.Any);

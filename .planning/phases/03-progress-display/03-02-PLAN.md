---
phase: 03-progress-display
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/sync/engine.go
  - app.go
autonomous: true

must_haves:
  truths:
    - "Engine uses ProgressAggregator instead of direct callbacks"
    - "Progress events are throttled (not per-chunk)"
    - "sync:progress event emits AggregateProgress shape"
    - "Sync start/end lifecycle events are emitted"
  artifacts:
    - path: "internal/sync/engine.go"
      provides: "ProgressAggregator integration"
      contains: "progressAggregator"
    - path: "app.go"
      provides: "Updated callback to emit AggregateProgress"
      contains: "AggregateProgress"
  key_links:
    - from: "internal/sync/engine.go"
      to: "internal/sync/progress.go"
      via: "ProgressAggregator instance"
      pattern: "NewProgressAggregator"
    - from: "app.go"
      to: "internal/models/progress.go"
      via: "callback type"
      pattern: "models\\.AggregateProgress"
---

<objective>
Integrate ProgressAggregator into the sync engine, replacing direct per-chunk callbacks with throttled aggregate emissions.

Purpose: Connect the new progress infrastructure to the existing sync flow. The engine will feed file progress into the aggregator, which emits throttled updates to the frontend via Wails events.

Output:
- Updated `internal/sync/engine.go` with ProgressAggregator integration
- Updated `app.go` with new callback signature
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-progress-display/03-RESEARCH.md
@.planning/phases/03-progress-display/03-01-SUMMARY.md

# Source files to modify
@internal/sync/engine.go
@internal/sync/progress.go
@internal/models/progress.go
@app.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate ProgressAggregator into Engine</name>
  <files>internal/sync/engine.go</files>
  <action>
Modify `internal/sync/engine.go` to:

1. Add progressAggregator field to Engine struct (around line 48):
```go
type Engine struct {
    // ... existing fields ...
    progressAggregator *ProgressAggregator  // NEW: add after progress field
    // ... rest of fields ...
}
```

2. Add new callback type and setter (around line 169-171):
```go
// Change the callback type to accept AggregateProgress
onAggregateProgress func(*models.AggregateProgress)

// Add new setter method (keep old SetProgressCallback for backward compat)
func (e *Engine) SetAggregateProgressCallback(cb func(*models.AggregateProgress)) {
    e.onAggregateProgress = cb
    e.progressAggregator = NewProgressAggregator(cb)
}
```

3. Modify pushFile() (around lines 782-820) to use aggregator:
```go
func (e *Engine) pushFile(conn *network.PeerConnection, fp *models.FolderPair, fileInfo *models.FileInfo) {
    if fileInfo.IsDir {
        return
    }

    tm := NewTransferManager(fp.LocalPath, e.scanner)

    // Use aggregator-aware callback
    progressCb := func(p *models.TransferProgress) {
        // Update legacy progress
        e.mu.Lock()
        e.progress = p
        e.mu.Unlock()

        // Feed into aggregator if available
        if e.progressAggregator != nil {
            e.progressAggregator.UpdateFile(p.FileName, p.TotalBytes, p.TransferBytes)
        } else if e.onProgress != nil {
            // Legacy fallback
            e.onProgress(p)
        }
    }

    if err := tm.SendFile(conn, fp.ID, fileInfo.Path, progressCb); err != nil {
        // ... existing error handling ...
        return
    }

    // Mark file complete in aggregator
    if e.progressAggregator != nil {
        e.progressAggregator.CompleteFile(fileInfo.Path)
    }

    // ... rest of existing event code ...
}
```

4. Modify handleFileChunk() (around lines 877-942) similarly:
```go
func (e *Engine) handleFileChunk(conn *network.PeerConnection, msg *network.Message) {
    // ... existing code until NewFileReceiver ...

    var err error
    receiver, err = NewFileReceiver(fp.LocalPath, payload.FilePath, 0, func(p *models.TransferProgress) {
        e.mu.Lock()
        e.progress = p
        e.mu.Unlock()

        // Feed into aggregator if available
        if e.progressAggregator != nil {
            e.progressAggregator.UpdateFile(p.FileName, p.TotalBytes, p.TransferBytes)
        } else if e.onProgress != nil {
            e.onProgress(p)
        }
    })

    // ... rest of existing code ...

    if payload.IsLast {
        // ... existing finalize code ...

        // Mark file complete in aggregator
        if e.progressAggregator != nil {
            e.progressAggregator.CompleteFile(payload.FilePath)
        }

        // ... existing event code ...
    }
}
```

5. Add sync lifecycle methods to engine:
```go
// NotifySyncStart notifies progress aggregator of sync start
func (e *Engine) NotifySyncStart(totalFiles int, totalBytes int64) {
    if e.progressAggregator != nil {
        e.progressAggregator.StartSync(totalFiles, totalBytes)
    }
}

// NotifySyncEnd notifies progress aggregator of sync end
func (e *Engine) NotifySyncEnd() {
    if e.progressAggregator != nil {
        e.progressAggregator.EndSync()
    }
}

// GetAggregateProgress returns current aggregate progress
func (e *Engine) GetAggregateProgress() *models.AggregateProgress {
    if e.progressAggregator != nil {
        return e.progressAggregator.GetProgress()
    }
    return nil
}
```

6. Update handleIndexExchange() (around line 730) to call NotifySyncStart before processing actions:
```go
func (e *Engine) handleIndexExchange(conn *network.PeerConnection, msg *network.Message) {
    // ... existing index parsing ...

    // Compare indices
    actions := CompareIndices(localIndex, remoteIndex)

    // Calculate totals for progress tracking
    var totalFiles int
    var totalBytes int64
    for _, action := range actions {
        if action.Action == models.FileActionPush && action.LocalFile != nil && !action.LocalFile.IsDir {
            totalFiles++
            totalBytes += action.LocalFile.Size
        } else if action.Action == models.FileActionPull && action.RemoteFile != nil && !action.RemoteFile.IsDir {
            totalFiles++
            totalBytes += action.RemoteFile.Size
        }
    }

    // Notify sync start
    e.NotifySyncStart(totalFiles, totalBytes)

    // Execute actions
    for _, action := range actions {
        // ... existing action processing ...
    }

    // Notify sync end
    e.NotifySyncEnd()

    // ... rest of existing code ...
}
```

IMPORTANT: Preserve all existing functionality. The changes add aggregator support without removing legacy callback support.
  </action>
  <verify>
Run `go build ./...` - should compile without errors.
Grep for new methods: `grep -n "SetAggregateProgressCallback\|progressAggregator\|NotifySyncStart" internal/sync/engine.go`
  </verify>
  <done>
Engine integrates ProgressAggregator:
- progressAggregator field added
- SetAggregateProgressCallback() method added
- pushFile() and handleFileChunk() feed updates to aggregator
- NotifySyncStart/End lifecycle methods added
- Backward compatibility with old callback preserved
  </done>
</task>

<task type="auto">
  <name>Task 2: Update app.go to use AggregateProgress</name>
  <files>app.go</files>
  <action>
Modify `app.go` to:

1. Update the progress callback setup (find where SetProgressCallback is called, around line 78-80):
```go
// Replace old callback:
// engine.SetProgressCallback(func(progress *models.TransferProgress) {
//     a.app.Event.Emit("sync:progress", progress)
// })

// With new aggregate callback:
engine.SetAggregateProgressCallback(func(progress *models.AggregateProgress) {
    a.app.Event.Emit("sync:progress", progress)
})
```

2. Add method to get current aggregate progress (for initial load):
```go
// GetAggregateProgress returns current sync progress
func (a *App) GetAggregateProgress() *models.AggregateProgress {
    if a.engine == nil {
        return nil
    }
    return a.engine.GetAggregateProgress()
}
```

3. Keep GetSyncProgress() for backward compatibility but have it return aggregate data if available:
```go
// GetSyncProgress returns current sync progress (legacy, returns first active file)
func (a *App) GetSyncProgress() *models.TransferProgress {
    if a.engine == nil {
        return nil
    }
    // Try aggregate first
    agg := a.engine.GetAggregateProgress()
    if agg != nil && len(agg.ActiveFiles) > 0 {
        f := agg.ActiveFiles[0]
        return &models.TransferProgress{
            FileName:       f.Path,
            TotalBytes:     f.Size,
            TransferBytes:  f.Transferred,
            Percentage:     f.Percentage,
            BytesPerSecond: int64(agg.BytesPerSecond),
        }
    }
    // Fallback to legacy
    return a.engine.GetProgress()
}
```

4. Add import for models.AggregateProgress if not already imported.

IMPORTANT: Keep the existing GetSyncProgress method working for backward compatibility with the current frontend until it's updated in Plan 03.
  </action>
  <verify>
Run `go build ./...` - should compile without errors.
Grep for new callback: `grep -n "SetAggregateProgressCallback\|GetAggregateProgress" app.go`
Verify both old and new methods exist.
  </verify>
  <done>
app.go updated:
- Uses SetAggregateProgressCallback for throttled aggregate events
- GetAggregateProgress() method added for frontend
- GetSyncProgress() maintains backward compatibility
- sync:progress event now emits AggregateProgress shape
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. `go build ./...` compiles successfully
2. `grep -n "progressAggregator" internal/sync/engine.go` shows field and usage
3. `grep -n "SetAggregateProgressCallback" app.go` shows new callback setup
4. Run app manually and verify sync:progress events are throttled (not every 1MB)
</verification>

<success_criteria>
- Engine has progressAggregator field initialized via SetAggregateProgressCallback
- pushFile() and handleFileChunk() feed progress to aggregator
- handleIndexExchange() calls NotifySyncStart/End
- app.go emits AggregateProgress via sync:progress event
- Backward compatibility with TransferProgress maintained
- Code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-progress-display/03-02-SUMMARY.md`
</output>

---
phase: 02-menu-bar-integration
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - internal/tray/tray.go
  - app.go
  - internal/sync/engine.go
autonomous: true

must_haves:
  truths:
    - "Tray icon shows idle state when not syncing"
    - "Tray icon changes to syncing state during file transfers"
    - "Tray icon shows error state when sync fails"
    - "Icon updates are triggered by sync engine status changes"
  artifacts:
    - path: "internal/tray/tray.go"
      provides: "SetState method for icon updates"
      contains: "SetState"
    - path: "app.go"
      provides: "Tray state updates in callbacks"
      contains: "tray.StateIdle|tray.StateSyncing|tray.StateError"
  key_links:
    - from: "app.go"
      to: "internal/tray/tray.go"
      via: "tray.SetState()"
      pattern: "SetState\\(tray\\.State"
    - from: "internal/sync/engine.go"
      to: "app.go"
      via: "StatusCallback"
      pattern: "SetStatusCallback"
---

<objective>
Implement dynamic tray icon states based on sync engine status.

Purpose: TRAY-03 (icon changes based on state: idle, syncing, error)

Output:
- Icon reflects current sync state
- State changes triggered by engine callbacks
- Visual feedback in menu bar
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-menu-bar-integration/02-RESEARCH.md
@.planning/phases/02-menu-bar-integration/02-02-PLAN.md
@internal/tray/tray.go
@app.go
@internal/sync/engine.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify tray.SetState exists and works</name>
  <files>
    internal/tray/tray.go
  </files>
  <action>
Verify that SetState method from Plan 02-02 is implemented correctly:

```go
// SetState updates the tray icon based on sync state
func (m *Manager) SetState(state State) {
    if runtime.GOOS != "darwin" {
        return
    }

    var icon []byte
    switch state {
    case StateIdle:
        icon = IconIdle
    case StateSyncing:
        icon = IconSyncing
    case StateError:
        icon = IconError
    default:
        icon = IconIdle
    }
    m.systray.SetTemplateIcon(icon)
}
```

If not present, add it. Also ensure State constants are exported:
```go
type State int

const (
    StateIdle State = iota
    StateSyncing
    StateError
)
```
  </action>
  <verify>
    Run `grep "func.*SetState" internal/tray/tray.go` - method exists
    Run `grep "StateIdle" internal/tray/tray.go` - constants exist
    Run `go build ./internal/tray/...` - compiles
  </verify>
  <done>
    - SetState method exists
    - State constants exported
    - Package compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Update app.go status callback to update tray</name>
  <files>
    app.go
  </files>
  <action>
Update the status callback in startup() to also update the tray icon:

```go
// In startup(), update the status callback:
engine.SetStatusCallback(func(status sync.SyncStatus, action string) {
    // Emit event for frontend
    a.app.Events.Emit(&application.WailsEvent{
        Name: "sync:status",
        Data: map[string]interface{}{
            "status": status,
            "action": action,
        },
    })

    // Update tray icon based on status
    if a.tray != nil {
        switch status {
        case sync.StatusIdle:
            a.tray.SetState(tray.StateIdle)
        case sync.StatusSyncing, sync.StatusConnecting:
            a.tray.SetState(tray.StateSyncing)
        case sync.StatusError:
            a.tray.SetState(tray.StateError)
        default:
            a.tray.SetState(tray.StateIdle)
        }
    }
})
```

Make sure to import the tray package if not already:
```go
import "SyncDev/internal/tray"
```
  </action>
  <verify>
    Run `grep "tray.StateIdle\|tray.StateSyncing\|tray.StateError" app.go` - all states used
    Run `go build ./...` - compiles
  </verify>
  <done>
    - Status callback updates tray icon
    - All three states mapped
    - Build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 3: Map sync engine status to tray states</name>
  <files>
    app.go
    internal/sync/engine.go
  </files>
  <action>
Verify the sync engine status constants and ensure proper mapping:

1. Check what status values the engine emits:
   ```bash
   grep "Status[A-Z]" internal/sync/engine.go
   ```

2. The engine likely has:
   - StatusIdle
   - StatusSyncing
   - StatusConnecting
   - StatusError (or similar)

3. Ensure all relevant statuses are mapped in app.go callback:
   ```go
   switch status {
   case sync.StatusIdle:
       a.tray.SetState(tray.StateIdle)
   case sync.StatusSyncing, sync.StatusConnecting, sync.StatusPreparing:
       a.tray.SetState(tray.StateSyncing)
   case sync.StatusError, sync.StatusDisconnected:
       a.tray.SetState(tray.StateError)
   default:
       a.tray.SetState(tray.StateIdle)
   }
   ```

4. If engine has more granular states, map them appropriately:
   - Any "working" state → StateSyncing
   - Any "problem" state → StateError
   - Any "ready" state → StateIdle
  </action>
  <verify>
    Run `go build ./...` - compiles
    Run `grep -c "SetState" app.go` - at least 3 calls in switch
  </verify>
  <done>
    - All engine statuses mapped to tray states
    - Switch statement covers all cases
    - Build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 4: Add error state on engine failures</name>
  <files>
    app.go
  </files>
  <action>
Ensure error state is shown when sync operations fail:

1. Update the event callback (if separate from status callback):
   ```go
   engine.SetEventCallback(func(event *sync.SyncEvent) {
       // Emit to frontend
       a.app.Events.Emit(&application.WailsEvent{
           Name: "sync:event",
           Data: event,
       })

       // Set error state on failure events
       if a.tray != nil && event.Type == "error" {
           a.tray.SetState(tray.StateError)
       }
   })
   ```

2. Alternatively, if errors are conveyed via status callback, ensure the mapping includes them (already done in Task 2).

3. Consider adding a timeout to clear error state after a period, or clear it when next sync starts:
   ```go
   // In status callback, at start of syncing:
   case sync.StatusSyncing:
       a.tray.SetState(tray.StateSyncing)  // This clears any error state
   ```
  </action>
  <verify>
    Run `go build ./...` - compiles
  </verify>
  <done>
    - Error state set on failures
    - Error clears on next sync
    - Build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 5: Verify complete flow</name>
  <files>
    main.go
    app.go
    internal/tray/tray.go
  </files>
  <action>
Verify the complete icon state flow:

1. Build successfully:
   ```bash
   go build ./...
   ```

2. Verify state flow is wired:
   ```bash
   # Engine emits status
   grep "SetStatusCallback" app.go

   # App receives and updates tray
   grep "tray.SetState" app.go

   # Tray updates icon
   grep "SetTemplateIcon" internal/tray/tray.go
   ```

3. Run all tests:
   ```bash
   go test ./...
   ```

4. Verify icon assets exist:
   ```bash
   ls internal/tray/icons/*.png
   ```
  </action>
  <verify>
    All grep commands return matches
    Build succeeds
    Tests pass
  </verify>
  <done>
    - Complete flow from engine → app → tray → icon
    - All tests pass
    - Icon assets in place
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build succeeds:
   ```bash
   go build ./...
   ```

2. Tests pass:
   ```bash
   go test ./...
   ```

3. State flow verified:
   ```bash
   grep "SetStatusCallback" app.go
   grep "tray.SetState" app.go
   grep "SetTemplateIcon" internal/tray/tray.go
   ```

4. All three states used:
   ```bash
   grep -E "StateIdle|StateSyncing|StateError" app.go
   ```
</verification>

<success_criteria>
- [ ] tray.SetState() method exists and works
- [ ] app.go status callback calls tray.SetState()
- [ ] StatusIdle → tray.StateIdle
- [ ] StatusSyncing/Connecting → tray.StateSyncing
- [ ] StatusError → tray.StateError
- [ ] Error events update tray icon
- [ ] `go build ./...` succeeds
- [ ] `go test ./...` passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-menu-bar-integration/02-03-SUMMARY.md`
</output>

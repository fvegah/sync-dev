---
phase: 01-keychain-security
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/sync/engine.go
autonomous: true

must_haves:
  truths:
    - "Engine loads secrets from keychain when connecting to peers"
    - "New secrets generated during pairing are stored in keychain"
    - "Secrets are NOT stored in config.json when peers are added/updated"
  artifacts:
    - path: "internal/sync/engine.go"
      provides: "Keychain integration for peer connections"
      contains: "GetSecrets"
  key_links:
    - from: "internal/sync/engine.go"
      to: "internal/config/store.go"
      via: "store.GetSecrets()"
      pattern: "store\\.GetSecrets\\(\\)"
    - from: "internal/sync/engine.go"
      to: "internal/secrets/keychain.go"
      via: "secrets.Manager interface"
      pattern: "SetSecret|GetSecret"
---

<objective>
Update the sync engine to use keychain for all secret operations instead of storing secrets in config.json.

Purpose: Complete the keychain integration by ensuring the engine (which handles pairing and connections) uses the keychain for all secret storage and retrieval.

Output:
- Engine uses `store.GetSecrets()` to get/set/delete secrets
- New secrets from pairing go directly to keychain
- Peer.SharedSecret field is no longer written to (only read for backward compat during migration)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-keychain-security/01-RESEARCH.md
@.planning/phases/01-keychain-security/01-01-SUMMARY.md
@internal/sync/engine.go
@internal/config/store.go
@internal/secrets/keychain.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update engine to load secrets from keychain when connecting</name>
  <files>
    internal/sync/engine.go
  </files>
  <action>
The engine currently sets `conn.SharedSecret = peer.SharedSecret` when establishing connections. Update this to load from keychain instead.

1. Find all places where `peer.SharedSecret` is READ to set `conn.SharedSecret`:
   - Around line 206: `dp.SharedSecret = cp.SharedSecret`
   - Around line 448: `conn.SharedSecret = peer.SharedSecret`
   - Around line 520: `conn.SharedSecret = peer.SharedSecret`
   - Around line 544: `peer.SharedSecret = existingPeer.SharedSecret`

2. For each location where `conn.SharedSecret` is being set from `peer.SharedSecret`:
   - Replace with call to load from keychain:
     ```go
     secret, err := e.store.GetSecrets().GetSecret(peer.ID)
     if err != nil && err != secrets.ErrSecretNotFound {
         log.Printf("Warning: failed to load secret for peer %s: %v", peer.ID, err)
     }
     conn.SharedSecret = secret
     ```
   - Add import for `SyncDev/internal/secrets` at top of file

3. For the case around line 544 where existing peer secret is copied to discovered peer:
   - Load from keychain instead:
     ```go
     // Don't copy SharedSecret from existingPeer - it's in keychain
     // Secret will be loaded when connection is established
     ```
   - Remove the line `peer.SharedSecret = existingPeer.SharedSecret`

Important: Do NOT change the `PeerConnection.SharedSecret` field itself - it's still needed for runtime HMAC verification. Only change where we SOURCE the secret from (keychain instead of config).
  </action>
  <verify>
    Run `go build ./...` - no compilation errors
    Run `go test ./internal/sync/... -v` - existing tests pass (if any)
  </verify>
  <done>
    - All reads of peer.SharedSecret for setting conn.SharedSecret replaced with keychain lookup
    - secrets package imported
    - Build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Update engine to store new secrets in keychain</name>
  <files>
    internal/sync/engine.go
  </files>
  <action>
The engine generates and stores secrets during pairing. Update these to store in keychain instead of peer.SharedSecret.

1. Find all places where `peer.SharedSecret` is WRITTEN:
   - Around line 610: `peer.SharedSecret = secret` (after generating secret for outgoing pairing)
   - Around line 656: `peer.SharedSecret = payload.SharedSecret` (after receiving secret from incoming pairing)
   - Around line 1082: `peer.SharedSecret = secret` (pairing acceptance)
   - Around line 1107: `peer.SharedSecret = ""` (pairing rejection)

2. For each WRITE to `peer.SharedSecret`:
   - Replace with keychain storage:
     ```go
     // Store in keychain
     if err := e.store.GetSecrets().SetSecret(peer.ID, secret); err != nil {
         log.Printf("Error: failed to store secret for peer %s: %v", peer.ID, err)
         // Continue anyway - pairing may still work for this session
     }
     // Don't set peer.SharedSecret - it stays empty in config
     ```

3. For the rejection case (clearing secret):
   - Replace with keychain delete:
     ```go
     // Delete from keychain
     if err := e.store.GetSecrets().DeleteSecret(peer.ID); err != nil {
         log.Printf("Warning: failed to delete secret for peer %s: %v", peer.ID, err)
     }
     ```

4. Also set `conn.SharedSecret` after storing to keychain so the current session works:
   ```go
   if err := e.store.GetSecrets().SetSecret(peer.ID, secret); err != nil {
       log.Printf("Error: failed to store secret for peer %s: %v", peer.ID, err)
   }
   conn.SharedSecret = secret  // For current session
   ```

Important: After these changes, `peer.SharedSecret` (the config struct field) should NEVER be written to. It may still be read during migration but that's handled by Plan 01.
  </action>
  <verify>
    Run `go build ./...` - no compilation errors
    Run `grep -n "peer.SharedSecret = " internal/sync/engine.go` - should return NO results (no writes to peer.SharedSecret)
  </verify>
  <done>
    - All writes to peer.SharedSecret replaced with keychain SetSecret/DeleteSecret
    - conn.SharedSecret still set for runtime use
    - No more writes to peer.SharedSecret field
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify and test end-to-end</name>
  <files>
    internal/sync/engine.go
  </files>
  <action>
1. Search for any remaining uses of `peer.SharedSecret` in engine.go:
   ```bash
   grep -n "\.SharedSecret" internal/sync/engine.go
   ```
   - Only `conn.SharedSecret` assignments should remain
   - `peer.SharedSecret` should not be read or written (except possibly in backward compat code during load)

2. Verify the patterns:
   - `conn.SharedSecret = ...` is OK (runtime use)
   - `e.store.GetSecrets().GetSecret(...)` for loading
   - `e.store.GetSecrets().SetSecret(...)` for storing
   - `e.store.GetSecrets().DeleteSecret(...)` for cleanup

3. Add a helper method if it makes the code cleaner:
   ```go
   // getSecretForPeer loads a peer's shared secret from keychain
   func (e *Engine) getSecretForPeer(peerID string) string {
       secret, err := e.store.GetSecrets().GetSecret(peerID)
       if err != nil && err != secrets.ErrSecretNotFound {
           log.Printf("Warning: failed to load secret for peer %s: %v", peerID, err)
       }
       return secret
   }
   ```
   Then use `e.getSecretForPeer(peer.ID)` instead of inline keychain calls.

4. Run full build and test:
   ```bash
   go build ./...
   go test ./...
   ```
  </action>
  <verify>
    Run `go build ./...` - compiles successfully
    Run `go test ./... -v` - all tests pass
    Run `grep "peer\.SharedSecret" internal/sync/engine.go | grep -v "//"` - no uncommented references to peer.SharedSecret
  </verify>
  <done>
    - No remaining peer.SharedSecret usage except comments
    - Helper method added if appropriate
    - Full build and test pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build succeeds:
   ```bash
   go build ./...
   ```

2. All tests pass:
   ```bash
   go test ./... -v
   ```

3. No peer.SharedSecret usage in engine (except backward compat):
   ```bash
   grep -n "peer\.SharedSecret" internal/sync/engine.go
   # Should show no writes (= assignments)
   ```

4. Keychain patterns present:
   ```bash
   grep -n "GetSecrets" internal/sync/engine.go
   # Should show multiple calls
   ```
</verification>

<success_criteria>
- [ ] Engine loads secrets from keychain via `store.GetSecrets().GetSecret()`
- [ ] Engine stores new secrets to keychain via `store.GetSecrets().SetSecret()`
- [ ] Engine deletes secrets via `store.GetSecrets().DeleteSecret()` on unpair
- [ ] `peer.SharedSecret` is never written to in engine.go
- [ ] `conn.SharedSecret` is still set for runtime HMAC operations
- [ ] `go build ./...` succeeds
- [ ] `go test ./...` passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-keychain-security/01-02-SUMMARY.md`
</output>

---
phase: 01-keychain-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/secrets/keychain.go
  - internal/secrets/keychain_test.go
  - internal/config/store.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "Secrets are stored in macOS Keychain, not in config.json"
    - "Existing plaintext secrets migrate automatically on first load"
    - "Config.json no longer contains SharedSecret values after migration"
  artifacts:
    - path: "internal/secrets/keychain.go"
      provides: "Keychain manager interface and implementation"
      exports: ["Manager", "KeychainManager", "ErrSecretNotFound"]
      min_lines: 50
    - path: "internal/secrets/keychain_test.go"
      provides: "Test coverage using keyring.MockInit()"
      contains: "MockInit"
    - path: "internal/config/store.go"
      provides: "Migration logic and secrets manager integration"
      contains: "migrateSecretsToKeychain"
  key_links:
    - from: "internal/config/store.go"
      to: "internal/secrets/keychain.go"
      via: "secrets.Manager interface"
      pattern: "secrets\\.Manager"
    - from: "internal/config/store.go"
      to: "github.com/zalando/go-keyring"
      via: "secrets package import"
      pattern: "SyncDev/internal/secrets"
---

<objective>
Create the keychain secrets manager and integrate it with the config store, including automatic migration of existing plaintext secrets.

Purpose: Secure storage of shared secrets in macOS Keychain instead of plaintext config.json. This is the foundation for Phase 1 security improvements.

Output:
- New `internal/secrets/keychain.go` with Manager interface and KeychainManager implementation
- New `internal/secrets/keychain_test.go` with mock-based tests
- Updated `internal/config/store.go` with migration logic
- Plaintext secrets automatically migrated to Keychain on first load
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-keychain-security/01-RESEARCH.md
@internal/config/store.go
@internal/config/config.go
@internal/models/peer.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create keychain secrets manager</name>
  <files>
    internal/secrets/keychain.go
    internal/secrets/keychain_test.go
    go.mod
    go.sum
  </files>
  <action>
1. Add go-keyring dependency:
   ```bash
   go get github.com/zalando/go-keyring@v0.2.6
   ```

2. Create `internal/secrets/keychain.go`:
   - Define const `ServiceName = "com.syncdev.secrets"`
   - Define var `ErrSecretNotFound = errors.New("secret not found")`
   - Define `Manager` interface with methods:
     - `GetSecret(peerID string) (string, error)`
     - `SetSecret(peerID, secret string) error`
     - `DeleteSecret(peerID string) error`
   - Implement `KeychainManager` struct (empty - uses keyring package functions)
   - `GetSecret`: Call `keyring.Get(ServiceName, peerID)`, return `ErrSecretNotFound` if `keyring.ErrNotFound`
   - `SetSecret`: Call `keyring.Set(ServiceName, peerID, secret)`
   - `DeleteSecret`: Call `keyring.Delete(ServiceName, peerID)`, ignore `keyring.ErrNotFound`
   - Add `NewKeychainManager() *KeychainManager` constructor

3. Create `internal/secrets/keychain_test.go`:
   - Use `keyring.MockInit()` in each test or TestMain
   - Test `SetSecret` then `GetSecret` returns same value
   - Test `GetSecret` for nonexistent returns `ErrSecretNotFound`
   - Test `DeleteSecret` removes the secret
   - Test `DeleteSecret` on nonexistent does not error
  </action>
  <verify>
    Run `go test ./internal/secrets/...` - all tests pass
    Run `go build ./...` - no compilation errors
  </verify>
  <done>
    - `internal/secrets/keychain.go` exists with Manager interface and KeychainManager
    - `internal/secrets/keychain_test.go` passes all tests
    - go-keyring v0.2.6 in go.mod
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate keychain with config Store and add migration</name>
  <files>
    internal/config/store.go
  </files>
  <action>
1. Add import for `SyncDev/internal/secrets`

2. Add field to Store struct:
   ```go
   secrets secrets.Manager
   ```

3. Update `NewStore()`:
   - After creating Store, initialize secrets manager:
     ```go
     store.secrets = secrets.NewKeychainManager()
     ```
   - After `store.load()` succeeds, call migration:
     ```go
     if err := store.migrateSecretsToKeychain(); err != nil {
         log.Printf("Warning: secret migration failed: %v", err)
         // Don't fail startup - secrets may work from plaintext
     }
     ```

4. Add `migrateSecretsToKeychain()` method:
   ```go
   func (s *Store) migrateSecretsToKeychain() error {
       s.mu.Lock()
       defer s.mu.Unlock()

       migrated := false
       for _, peer := range s.config.Peers {
           if peer.SharedSecret == "" || !peer.Paired {
               continue
           }

           // Check if already in keychain
           existing, err := s.secrets.GetSecret(peer.ID)
           if err == nil && existing != "" {
               // Already migrated, just clear from config
               peer.SharedSecret = ""
               migrated = true
               continue
           }

           // Store in keychain
           if err := s.secrets.SetSecret(peer.ID, peer.SharedSecret); err != nil {
               return fmt.Errorf("migrate secret for peer %s: %w", peer.ID, err)
           }

           log.Printf("Migrated secret for peer %s to keychain", peer.Name)
           peer.SharedSecret = ""
           migrated = true
       }

       if migrated {
           return s.saveUnlocked() // Save config without secrets
       }
       return nil
   }
   ```

5. Add `GetSecrets() secrets.Manager` method to expose secrets manager:
   ```go
   func (s *Store) GetSecrets() secrets.Manager {
       return s.secrets
   }
   ```

Note: Do NOT modify how peers are loaded or saved in config.json. Only clear SharedSecret field after successful keychain migration.
  </action>
  <verify>
    Run `go build ./...` - no compilation errors
    Run `go test ./internal/config/...` - existing tests still pass (if any)
  </verify>
  <done>
    - Store has secrets field and GetSecrets() method
    - migrateSecretsToKeychain() exists and is called on NewStore()
    - Migration clears SharedSecret from config after storing in keychain
    - Config saves without plaintext secrets after migration
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Store test for migration</name>
  <files>
    internal/config/store_test.go
  </files>
  <action>
1. Create `internal/config/store_test.go` if it doesn't exist

2. Add test for migration:
   ```go
   func TestMigrateSecretsToKeychain(t *testing.T) {
       keyring.MockInit() // Use mock keychain

       // Create temp dir for config
       tmpDir := t.TempDir()

       // Create a config file with plaintext secrets
       configPath := filepath.Join(tmpDir, "config.json")
       config := &Config{
           DeviceID:   "test-device",
           DeviceName: "Test",
           Port:       52525,
           Peers: []*models.Peer{
               {
                   ID:           "peer-123",
                   Name:         "Test Peer",
                   SharedSecret: "secret-value",
                   Paired:       true,
               },
           },
       }
       data, _ := json.MarshalIndent(config, "", "  ")
       os.WriteFile(configPath, data, 0644)

       // Load store (should trigger migration)
       store, err := NewStoreWithPath(configPath)
       if err != nil {
           t.Fatalf("Failed to create store: %v", err)
       }

       // Verify secret is in keychain
       secret, err := store.GetSecrets().GetSecret("peer-123")
       if err != nil {
           t.Fatalf("Failed to get secret from keychain: %v", err)
       }
       if secret != "secret-value" {
           t.Errorf("Expected 'secret-value', got '%s'", secret)
       }

       // Verify secret cleared from config
       cfg := store.Get()
       if cfg.Peers[0].SharedSecret != "" {
           t.Error("SharedSecret should be empty in config after migration")
       }

       // Verify config file no longer contains secret
       data, _ = os.ReadFile(configPath)
       if strings.Contains(string(data), "secret-value") {
           t.Error("Config file still contains plaintext secret")
       }
   }
   ```

3. Add `NewStoreWithPath(configPath string)` constructor variant to store.go to enable testing:
   ```go
   func NewStoreWithPath(configPath string) (*Store, error) {
       store := &Store{
           configPath: configPath,
           secrets:    secrets.NewKeychainManager(),
       }

       if err := store.load(); err != nil {
           return nil, err
       }

       if err := store.migrateSecretsToKeychain(); err != nil {
           log.Printf("Warning: secret migration failed: %v", err)
       }

       return store, nil
   }
   ```
  </action>
  <verify>
    Run `go test ./internal/config/... -v` - migration test passes
  </verify>
  <done>
    - store_test.go has migration test
    - NewStoreWithPath() constructor exists for testing
    - Test verifies secret moved to keychain and cleared from config
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Unit tests pass:
   ```bash
   go test ./internal/secrets/... ./internal/config/... -v
   ```

2. Build succeeds:
   ```bash
   go build ./...
   ```

3. Manual verification (optional):
   - Create a config.json with a peer that has SharedSecret
   - Run the app
   - Check config.json - SharedSecret should be empty
   - Check keychain via `security find-generic-password -s com.syncdev.secrets -a <peer-id>`
</verification>

<success_criteria>
- [ ] `internal/secrets/keychain.go` implements Manager interface
- [ ] `internal/secrets/keychain_test.go` has passing tests with MockInit
- [ ] `internal/config/store.go` has migration logic
- [ ] Migration runs on NewStore() and clears SharedSecret from config
- [ ] All tests pass: `go test ./internal/secrets/... ./internal/config/...`
- [ ] Build succeeds: `go build ./...`
</success_criteria>

<output>
After completion, create `.planning/phases/01-keychain-security/01-01-SUMMARY.md`
</output>
